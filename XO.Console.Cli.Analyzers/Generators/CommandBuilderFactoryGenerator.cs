using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace XO.Console.Cli.Generators;

[Generator(LanguageNames.CSharp)]
public sealed class CommandBuilderFactoryGenerator : IIncrementalGenerator
{
    private sealed record CommandTypeModel(
        Location Location,
        string Name,
        string? ParametersName);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var referenceMaterial = context.CompilationProvider.Select(
            (compilation, _) =>
            {
                var commandInterface = compilation.GetTypeByMetadataName("XO.Console.Cli.ICommand`1");

                return (compilation.AssemblyName, CommandInterface: commandInterface);
            });

        var classDeclarations = context.SyntaxProvider.ForAttributeWithMetadataName(
            "XO.Console.Cli.CommandAttribute",
            predicate: static (node, cancellationToken) => node is ClassDeclarationSyntax,
            transform: static (context, cancellationToken) => (INamedTypeSymbol)context.TargetSymbol)
            .WithComparer(SymbolEqualityComparer.Default);

        var classDeclarationsWithReferenceMaterial = classDeclarations.Combine(referenceMaterial);

        var models = classDeclarationsWithReferenceMaterial.Select(
            (x, cancellationToken) =>
            {
                var (assemblyName, commandInterface) = x.Right;

                if (commandInterface is null)
                    return null;

                var commandType = x.Left;
                if (commandType.IsAbstract)
                    return null;

                ITypeSymbol? commandParametersType = null;

                foreach (var @interface in commandType.AllInterfaces)
                {
                    if (commandInterface.Equals(@interface.ConstructedFrom, SymbolEqualityComparer.Default))
                    {
                        commandParametersType = @interface.TypeArguments[0];
                        break;
                    }
                }

                return new CommandTypeModel(
                    commandType.Locations[0],
                    commandType.ToSourceString(),
                    commandParametersType?.ToSourceString());
            })
            .Where(model => model is not null)
            .Collect();

        context.RegisterSourceOutput(
            models,
            static (context, source) => Execute(context, source));
    }

    private static void Execute(SourceProductionContext context, ImmutableArray<CommandTypeModel?> models)
    {
        var builder = new StringBuilder();

        builder.AppendLine(
            $$"""
            // <auto-generated/>
            using System;
            using System.Diagnostics.CodeAnalysis;
            using XO.Console.Cli;
            using XO.Console.Cli.Infrastructure;

            #nullable enable

            namespace {{ThisAssembly.RootNamespace}}.Generated;

            /// <summary>
            /// This class was auto-generated to support the <c>XO.Console.Cli</c> infrastructure. It is not intended to be used directly from your code.
            /// </summary>
            [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{ThisAssembly.AssemblyName}}", "{{ThisAssembly.AssemblyVersion}}")]
            [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]
            internal sealed class CommandBuilderFactory : ICommandBuilderFactory
            {
            #pragma warning disable CS0436 // Type conflicts with imported type
                public static readonly CommandBuilderFactory Instance = new CommandBuilderFactory();
            #pragma warning restore CS0436 // Type conflicts with imported type

                public CommandBuilder? CreateCommandBuilder<[DynamicallyAccessedMembers(DynamicallyAccessedMemberTypes.PublicConstructors)] TCommand>(string verb)
                    where TCommand : class, ICommand
                {
            """);

        builder.AppendLine();

        foreach (var model in models)
        {
            if (model!.ParametersName is null)
            {
                var diagnostic = Diagnostic.Create(
                    DiagnosticDescriptors.CommandTypeMustImplementICommand,
                    model.Location,
                    model.Name);

                context.ReportDiagnostic(diagnostic);
                continue;
            }

            EmitCommandFactoryCase(builder, model);
        }

        builder.AppendLine(
            $$"""

                    return null;
                }

                [global::System.Runtime.CompilerServices.ModuleInitializerAttribute]
                internal static void Register()
                {
                    TypeRegistry.RegisterCommandBuilderFactory(Instance);
                }
            }
            """);

        context.AddSource("CommandBuilderFactory.g.cs", builder.ToString());
    }

    private static void EmitCommandFactoryCase(StringBuilder builder, CommandTypeModel model)
    {
        builder.AppendLine(
            $$"""
                    if (typeof(TCommand) == typeof({{model.Name}}))
                    {
                        return new CommandBuilder<{{model.Name}}, {{model.ParametersName}}>(
                            verb,
                            static (resolver) => resolver.Get<{{model.Name}}>());
                    }
            """);
    }
}
