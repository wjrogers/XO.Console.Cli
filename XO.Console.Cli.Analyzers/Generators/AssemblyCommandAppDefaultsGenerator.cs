using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace XO.Console.Cli.Generators;

[Generator(LanguageNames.CSharp)]
public sealed class AssemblyCommandAppDefaultsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var assemblyInfoProvider = context.CompilationProvider.Select(
            static (compilation, cancellationToken) =>
            {
                string? assemblyDescription = null;
                string? assemblyInformationalVersion = null;
                string? assemblyVersion = null;

                foreach (var attribute in compilation.Assembly.GetAttributes())
                {
                    switch (attribute.AttributeClass?.ToSourceString())
                    {
                        case "System.Reflection.AssemblyDescriptionAttribute":
                            assemblyDescription = (string?)attribute.ConstructorArguments[0].Value;
                            break;
                        case "System.Reflection.AssemblyInformationalVersionAttribute":
                            assemblyInformationalVersion = (string?)attribute.ConstructorArguments[0].Value;
                            break;
                        case "System.Reflection.AssemblyVersionAttribute":
                            assemblyVersion = (string?)attribute.ConstructorArguments[0].Value;
                            break;
                    }
                }

                assemblyVersion ??= compilation.Assembly.Identity.Version.ToString();

                return new CommandAppAssemblyInfo(
                    compilation.AssemblyName,
                    assemblyDescription,
                    assemblyInformationalVersion ?? assemblyVersion);
            });

        context.RegisterImplementationSourceOutput(
            assemblyInfoProvider,
            static (context, assemblyInfo) =>
            {
                var literalAssemblyName = assemblyInfo.Name != null
                    ? LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(assemblyInfo.Name))
                    : LiteralExpression(SyntaxKind.NullLiteralExpression);
                var literalAssemblyDescription = assemblyInfo.Description != null
                    ? LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(assemblyInfo.Description))
                    : LiteralExpression(SyntaxKind.NullLiteralExpression);
                var literalAssemblyVersion = assemblyInfo.Version != null
                    ? LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(assemblyInfo.Version))
                    : LiteralExpression(SyntaxKind.NullLiteralExpression);

                var source =
                    $$"""
                    // <auto-generated/>
                    using XO.Console.Cli.Infrastructure;

                    #nullable enable

                    namespace {{ThisAssembly.RootNamespace}}.Generated;

                    /// <summary>
                    /// This class was auto-generated to support the <c>XO.Console.Cli</c> infrastructure. It is not intended to be used directly from your code.
                    /// </summary>
                    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{ThisAssembly.AssemblyName}}", "{{ThisAssembly.AssemblyVersion}}")]
                    [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]
                    internal static class AssemblyCommandAppDefaults
                    {
                        [global::System.Runtime.CompilerServices.ModuleInitializerAttribute]
                        public static void Initialize()
                        {
                            var entryAssembly = global::System.Reflection.Assembly.GetEntryAssembly();
                            var executingAssembly = global::System.Reflection.Assembly.GetExecutingAssembly();
                            if (executingAssembly == entryAssembly)
                            {
                                TypeRegistry.SetEntryAssemblyProperties(
                                    assemblyName: {{literalAssemblyName}},
                                    assemblyDescription: {{literalAssemblyDescription}},
                                    assemblyVersion: {{literalAssemblyVersion}});
                            }
                        }
                    }
                    """;

                context.AddSource("AssemblyCommandAppDefaults.g.cs", source);
            });
    }

    private readonly record struct CommandAppAssemblyInfo(
        string? Name,
        string? Description,
        string? Version);
}
