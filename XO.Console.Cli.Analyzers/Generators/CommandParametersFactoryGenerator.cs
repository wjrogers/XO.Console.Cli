using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using XO.Console.Cli.Model;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace XO.Console.Cli.Generators;

[Generator(LanguageNames.CSharp)]
public sealed class CommandParametersFactoryGenerator : IIncrementalGenerator
{
    private sealed record ParametersTypeModel(
        string Name,
        ImmutableArray<CommandArgumentModel> Arguments,
        ImmutableArray<CommandOptionModel> Options);

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var parametersTypes = context.SyntaxProvider.CreateSyntaxProvider(
            static (node, _) => node is ClassDeclarationSyntax decl,
            TransformParametersTypeDeclaration)
            .Where(x => x is not null)
            .Select((x, _) => x!);

        var combined = parametersTypes.Collect();

        context.RegisterImplementationSourceOutput(
            combined,
            static (context, x) => Execute(context, x));

    }

    private static void Execute(SourceProductionContext context, ImmutableArray<ParametersTypeModel> models)
    {
        var source = new StringBuilder();

        source.AppendLine(
            $$"""
            // <auto-generated/>
            using System;
            using System.Collections.Immutable;
            using XO.Console.Cli;
            using XO.Console.Cli.Infrastructure;
            using XO.Console.Cli.Model;
            using static XO.Console.Cli.Infrastructure.ParameterValueConverter;

            #nullable enable

            namespace {{ThisAssembly.RootNamespace}}.Generated;

            /// <summary>
            /// This class was auto-generated to support the <c>XO.Console.Cli</c> infrastructure. It is not intended to be used directly from your code.
            /// </summary>
            [global::System.CodeDom.Compiler.GeneratedCodeAttribute("{{ThisAssembly.AssemblyName}}", "{{ThisAssembly.AssemblyVersion}}")]
            [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Never)]
            internal sealed class CommandParametersFactory : ICommandParametersFactory
            {
            #pragma warning disable CS0436 // Type conflicts with imported type
                public static readonly CommandParametersFactory Instance = new CommandParametersFactory();
            #pragma warning restore CS0436 // Type conflicts with imported type

            """);

        source.AppendLine(
            $$"""
                public CommandParametersInfo? DescribeParameters(Type parametersType)
                {
                    if (parametersType is null)
                        throw new ArgumentNullException(nameof(parametersType));

            """);

        foreach (var model in models)
            EmitDescribeParametersCase(source, model);

        source.AppendLine(
            $$"""

                    return null;
                }

                [global::System.Runtime.CompilerServices.ModuleInitializerAttribute]
                internal static void Register()
                {
                    TypeRegistry.RegisterCommandParametersFactory(Instance);
                }
            }
            """);

        context.AddSource("CommandParametersFactory.g.cs", source.ToString());
    }

    private static void EmitDescribeParametersCase(StringBuilder source, ParametersTypeModel parametersModel)
    {
        source.AppendLine(
            $$"""
                    if (parametersType == typeof({{parametersModel.Name}}))
                    {
                        return new CommandParametersInfo(
            """);

        EmitDescribeParametersCaseArguments(source, parametersModel);
        EmitDescribeParametersCaseOptions(source, parametersModel);

        source.AppendLine(
            $$"""
                    }
            """);
    }

    private static void EmitDescribeParametersCaseArguments(StringBuilder source, ParametersTypeModel parametersModel)
    {
        var arguments = parametersModel.Arguments;

        if (arguments.Length == 0)
        {
            source.AppendLine(
            $$"""
                            ImmutableArray<CommandArgument>.Empty,
            """);
        }
        else
        {
            source.AppendLine(
            $$"""
                            ImmutableArray.Create<CommandArgument>(
            """);
        }

        for (int i = 0; i < arguments.Length; i++)
        {
            var model = arguments[i];
            source.AppendLine(
            $$"""
                                new CommandArgument(
                                    "{{model.Name}}",
                                    {{GetSetterLambdaExpression(model)}},
                                    typeof({{model.ParameterValueType}}),
                                    {{(model.Description is not null ? LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(model.Description)) : "null")}})
                                {
                                    Order = {{LiteralExpression(SyntaxKind.NumericLiteralExpression, Literal(model.Order))}},
                                    IsGreedy = {{LiteralExpression(model.IsGreedy ? SyntaxKind.TrueLiteralExpression : SyntaxKind.FalseLiteralExpression)}},
                                    IsOptional = {{LiteralExpression(model.IsOptional ? SyntaxKind.TrueLiteralExpression : SyntaxKind.FalseLiteralExpression)}},
                                }{{(i + 1 < arguments.Length ? "," : "),")}}
            """);
        }
    }

    private static void EmitDescribeParametersCaseOptions(StringBuilder source, ParametersTypeModel parametersModel)
    {
        var options = parametersModel.Options;

        if (options.Length == 0)
        {
            source.AppendLine(
            $$"""
                            ImmutableArray<CommandOption>.Empty);
            """);
        }
        else
        {
            source.AppendLine(
            $$"""
                            ImmutableArray.Create<CommandOption>(
            """);
        }

        for (int i = 0; i < options.Length; i++)
        {
            var model = options[i];
            source.AppendLine(
            $$"""
                                new CommandOption(
                                    "{{model.Name}}",
                                    {{GetSetterLambdaExpression(model)}},
                                    typeof({{model.ParameterValueType}}),
                                    {{(model.Description is not null ? LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(model.Description)) : "null")}})
                                {
                                    Aliases = ImmutableArray.Create<string>({{String.Join(", ", from alias in model.Aliases select LiteralExpression(SyntaxKind.StringLiteralExpression, Literal(alias)))}}),
                                    IsFlag = {{LiteralExpression(model.IsFlag ? SyntaxKind.TrueLiteralExpression : SyntaxKind.FalseLiteralExpression)}},
                                    IsHidden = {{LiteralExpression(model.IsHidden ? SyntaxKind.TrueLiteralExpression : SyntaxKind.FalseLiteralExpression)}},
                                }{{(i + 1 < options.Length ? "," : "));")}}
            """);
        }
    }

    private static string GetSetterLambdaExpression(CommandParameterModel parameter)
    {
        var defaultConverter = GetSetterDefaultConverter(parameter);

        switch (parameter.PropertyTypeKind)
        {
            case TypeKind.Array:
                return $$"""
                    static (context, values, converters) => (({{parameter.DeclaringType}})context.Parameters).{{parameter.PropertyName}} = ConvertArray<{{parameter.ParameterValueType}}>(values, converters, {{defaultConverter}})
                    """;

            default:
                return $$"""
                    static (context, values, converters) => (({{parameter.DeclaringType}})context.Parameters).{{parameter.PropertyName}} = ConvertSingle<{{parameter.ParameterValueType}}>(values, converters, {{defaultConverter}})
                    """;
        }
    }

    private static string GetSetterDefaultConverter(CommandParameterModel parameter)
    {
        switch (parameter.ParameterParsingStrategy)
        {
            case ParameterParsingStrategy.Constructor:
                return $$"""static (value) => new {{parameter.ParameterValueType}}(value)""";
            case ParameterParsingStrategy.Parse:
                return $$"""static (value) => {{parameter.ParameterValueType}}.Parse(value)""";
            case ParameterParsingStrategy.Enum:
            case ParameterParsingStrategy.None:
                return $$"""Parse{{parameter.ParameterParsingStrategy}}<{{parameter.ParameterValueType}}>""";
            case ParameterParsingStrategy.String:
                return $$"""static (value) => value""";
            default:
                return $$"""Parse{{parameter.ParameterParsingStrategy}}""";
        }
    }

    private static ParametersTypeModel? TransformParametersTypeDeclaration(GeneratorSyntaxContext context, CancellationToken cancellationToken)
    {
        var decl = (ClassDeclarationSyntax)context.Node;
        var declType = context.SemanticModel.GetDeclaredSymbol(decl)!;
        var typesToBindCount = 0;
        INamedTypeSymbol? commandParametersType = null;
        INamedTypeSymbol? currentType;

        // we only need to emit binders for types that can be instantiated
        if (declType.IsAbstract || declType.IsStatic)
            return null;

        // we only care about types that inherit from CommandParameters
        for (currentType = declType; currentType is not null; currentType = currentType.BaseType)
        {
            typesToBindCount++;
            if (currentType.EqualsSourceString("XO.Console.Cli.CommandParameters"))
            {
                commandParametersType = currentType;
                break;
            }
        }

        if (commandParametersType is null)
            return null;

        cancellationToken.ThrowIfCancellationRequested();

        var typesToBind = new Stack<INamedTypeSymbol>(typesToBindCount);
        var typesToBindArgumentCount = 0;
        var typesToBindOptionCount = 0;

        // now that we know this type inherits from CommandParameters, collect the types that may declare its parameters
        for (currentType = declType; !currentType.Equals(commandParametersType, SymbolEqualityComparer.Default); currentType = currentType.BaseType!)
        {
            typesToBind.Push(currentType);

            foreach (var member in currentType.GetMembers())
            {
                if (member.Kind != SymbolKind.Property)
                    continue;

                foreach (var attribute in member.GetAttributes())
                {
                    if (attribute.AttributeClass?.EqualsSourceString("XO.Console.Cli.CommandArgumentAttribute") == true)
                        typesToBindArgumentCount++;
                    else if (attribute.AttributeClass?.EqualsSourceString("XO.Console.Cli.CommandOptionAttribute") == true)
                        typesToBindOptionCount++;
                }
            }
        }

        cancellationToken.ThrowIfCancellationRequested();

        var arguments = ImmutableArray.CreateBuilder<CommandArgumentModel>(typesToBindArgumentCount);
        var options = ImmutableArray.CreateBuilder<CommandOptionModel>(typesToBindOptionCount);

        // finally, inspect the attributes
        while (typesToBind.Count > 0)
        {
            var type = typesToBind.Pop();

            cancellationToken.ThrowIfCancellationRequested();

            foreach (var member in type.GetMembers())
            {
                if (member.Kind != SymbolKind.Property || member is not IPropertySymbol property)
                    continue;

                var attributes = member.GetAttributes();
                string? description = null;

                foreach (var attribute in attributes)
                {
                    if (attribute.AttributeClass?.EqualsSourceString("System.ComponentModel.DescriptionAttribute") == true)
                    {
                        description = (string?)attribute.ConstructorArguments[0].Value;
                        break;
                    }
                }

                foreach (var attribute in attributes)
                {
                    if (attribute.AttributeClass?.EqualsSourceString("XO.Console.Cli.CommandArgumentAttribute") == true)
                    {
                        TransformArgument(arguments, attribute, property, description);
                    }
                    else if (attribute.AttributeClass?.EqualsSourceString("XO.Console.Cli.CommandOptionAttribute") == true)
                    {
                        TransformOption(options, attribute, property, description);
                    }
                }
            }
        }

        return new ParametersTypeModel(
            declType.ToSourceString(),
            arguments.MoveToImmutable(),
            options.MoveToImmutable());
    }

    private static void TransformArgument(
        ImmutableArray<CommandArgumentModel>.Builder builder,
        AttributeData attr,
        IPropertySymbol property,
        string? description)
    {
        if (attr.ConstructorArguments.Length != 2)
            return;
        if (attr.ConstructorArguments[1].IsNull)
            return;

        var order = (int)attr.ConstructorArguments[0].Value!;
        var name = (string)attr.ConstructorArguments[1].Value!;
        var greedy = default(bool);
        var optional = default(bool);

        foreach (var entry in attr.NamedArguments)
        {
            switch (entry.Key)
            {
                case nameof(ICommandArgumentAttributeData.IsGreedy):
                    greedy = (bool)entry.Value.Value!;
                    break;
                case nameof(ICommandArgumentAttributeData.IsOptional):
                    optional = (bool)entry.Value.Value!;
                    break;
            }
        }

        var model = new CommandArgumentModel(name, property, description)
        {
            Order = order,
            IsGreedy = greedy,
            IsOptional = optional,
        };

        builder.Add(model);
    }

    private static void TransformOption(
        ImmutableArray<CommandOptionModel>.Builder builder,
        AttributeData attr,
        IPropertySymbol property,
        string? description)
    {
        if (attr.ConstructorArguments.Length != 2)
            return;
        if (attr.ConstructorArguments[0].IsNull)
            return;

        var name = (string)attr.ConstructorArguments[0].Value!;
        var aliases = GetAliases(attr.ConstructorArguments[1]);
        var hidden = default(bool);

        foreach (var entry in attr.NamedArguments)
        {
            switch (entry.Key)
            {
                case nameof(ICommandOptionAttributeData.IsHidden):
                    hidden = (bool)entry.Value.Value!;
                    break;
            }
        }

        var model = new CommandOptionModel(name, property, description, aliases)
        {
            IsHidden = hidden,
        };

        builder.Add(model);
    }

    private static ImmutableArray<string> GetAliases(TypedConstant constructorArgument)
    {
        if (constructorArgument.IsNull)
            return ImmutableArray<string>.Empty;
        if (constructorArgument.Kind != TypedConstantKind.Array)
            return ImmutableArray<string>.Empty;

        var builder = ImmutableArray.CreateBuilder<string>(constructorArgument.Values.Length);

        foreach (var item in constructorArgument.Values)
            builder.Add((string)item.Value!);

        return builder.ToImmutable();
    }
}
